Code:
  (lambda ()
    (setq indent-tabs-mode nil)
    (elixir-ts-mode)
    (indent-region (point-min) (point-max)))

Point-Char: $

Name: Basic modules

=-=
defmodule Foobar do
def bar() do
"one"
      end
    end
=-=
defmodule Foobar do
  def bar() do
    "one"
  end
end
=-=-=


Name: Map

=-=
map = %{
  "a" => 1,
  "b" => 2
}
=-=-=

Name: Tuple

=-=
tuple = {
  :one,
  :two
}

{
  :one,
  :two
}

{:one,
 :two}
=-=-=

Name: Block assignments

=-=
foo =
  if true do
    "yes"
  else
    "no"
  end
=-=-=

Name: Function rescue

=-=
def foo do
  "bar"
rescue
  e ->
    "bar"
end
=-=-=


Name: Spec and method

=-=
@spec foobar(
        t,
        acc,
        (one, something -> :bar | far),
        (two -> :bar | far)
      ) :: any()
      when chunk: any
def foobar(enumerable, acc, chunk_fun, after_fun) do
  {_, {res, acc}} =
    case after_fun.(acc) do
      {:one, "one"} ->
        "one"

      {:two, "two"} ->
        "two"
    end
end
=-=-=

Name: With statement
=-=
with one <- one(),
     two <- two(),
     {:ok, value} <- get_value(one, two) do
  {:ok, value}
else
  {:error, {"Message" => message}} ->
    {:error, message}
end
=-=-=

Name: Spec return type

=-=
@type result ::
        {:done, term}
        | {:two}
        | {:one}

@type result ::
        {
          :done,
          term
        }
        | {:two}
        | {:one}

@type boo_bar ::
        (foo :: pos_integer, bar :: pos_integer -> any())

@type something() :: %{
        one: one(),
        two: two(),
        three: two()
      }

@spec foo_bar(
        t,
        (foo -> any),
        (() -> any) | (foo, foo -> boolean) | module()
      ) :: any
      when foo: any
def foo(one, fun, other)
=-=-=

Name: Pipe statements with fn

=-=
[1, 2]
|> Enum.map(fn num ->
  num + 1
end)
=-=-=

Name: Pipe statements with params

=-=
[1, 2]
|> Enum.map(
  one,
  two
)

"foo"
|> case do
  "foobar" ->
    # raise an issue
    raise "an error"
  other -> :other
end
=-=-=


Name: Binary operator in else block

=-=
defp foobar() do
  if false do
    :foo
  else
    :bar |> foo
  end
end
=-=-=

Name: Tuple indentation

=-=
{:ok,
 fn one ->
   one
   |> String.upcase(one)
 end}
=-=-=

Name: Parameter maps

=-=
def something(%{
      one: :one,
      two: :two
    }) do
  {:ok, "done"}
end
=-=-=
