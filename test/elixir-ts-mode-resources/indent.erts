Code:
  (lambda ()
    (setq indent-tabs-mode nil)
    (elixir-ts-mode)
    (indent-region (point-min) (point-max)))

Point-Char: $

Name: Basic modules

=-=
defmodule Foobar do
def bar() do
"one"
      end
    end
=-=
defmodule Foobar do
  def bar() do
    "one"
  end
end
=-=-=


Name: Map

=-=
map = %{
  "a" => 1,
  "b" => 2
}
=-=-=

Name: Block assignments

=-=
foo =
  if true do
    "yes"
  else
    "no"
  end
=-=-=

Name: Function rescue

=-=
def foo do
  "bar"
rescue
  e ->
    "bar"
end
=-=-=


Name: Spec and method

=-=
@spec foobar(
        t,
        acc,
        (one, something -> :bar | far),
        (two -> :bar | far)
      ) :: any()
      when chunk: any
def foobar(enumerable, acc, chunk_fun, after_fun) do
  {_, {res, acc}} =
    case after_fun.(acc) do
      {:one, "one"} ->
        "one"

      {:two, "two"} ->
        "two"
    end
end
=-=-=

Name: With statement
=-=
with one <- one(),
     two <- two(),
     {:ok, value} <- get_value(one, two) do
  {:ok, value}
else
  {:error, {"Message" => message} ->
    {:error, message}
end
=-=-=

Name: Spec return type

=-=
@type result ::
        {:done, term}
        | {:two}
        | {:one}

@type result ::
        {
          :done,
          term
        }
        | {:two}
        | {:one}

@type boo_bar ::
        (foo :: pos_integer, bar :: pos_integer -> any())
=-=-=


Name: Pipe statements with fn

=-=
[1, 2]
|> Enum.map(fn num ->
  num + 1
end)
=-=-=

Name: Pipe statements with params

=-=
[1, 2]
|> Enum.map(
  one,
  two
)
=-=-=
