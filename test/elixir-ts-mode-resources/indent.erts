Code:
  (lambda ()
    (setq indent-tabs-mode nil)
    (elixir-ts-mode)
    (indent-region (point-min) (point-max)))

Point-Char: $

Name: Basic modules

=-=
defmodule Foobar do
def bar() do
"one"
      end
    end
=-=
defmodule Foobar do
  def bar() do
    "one"
  end
end
=-=-=


Name: Map

=-=
map = %{
  "a" => 1,
  "b" => 2
}
=-=-=

Name: Tuple

=-=
tuple = {
  :one,
  :two
}

{
  :one,
  :two
}

{:one,
 :two}
=-=-=

Name: Block assignments

=-=
foo =
  if true do
    "yes"
  else
    "no"
  end
=-=-=

Name: Function rescue

=-=
def foo do
  "bar"
rescue
  e ->
    "bar"
end
=-=-=


Name: With statement
=-=
with one <- one(),
     two <- two(),
     {:ok, value} <- get_value(one, two) do
  {:ok, value}
else
  {:error, {"Message" => message}} ->
    {:error, message}
end
=-=-=

Name: Pipe statements with fn

=-=
[1, 2]
|> Enum.map(fn num ->
  num + 1
end)
=-=-=

Name: Pipe statements with params

=-=
[1, 2]
|> Enum.map(
  one,
  two
)

"foo"
|> case do
  "foobar" ->
    # raise an issue
    raise "an error"
  other -> :other
end
=-=-=


Name: Binary operator in else block

=-=
defp foobar() do
  if false do
    :foo
  else
    :bar |> foo
  end
end
=-=-=

Name: Tuple indentation

=-=
{:ok,
 fn one ->
   one
   |> String.upcase(one)
 end}
=-=-=


Name: Spec and method

=-=
@spec foobar(
        t,
        acc,
        (one, something -> :bar | far),
        (two -> :bar | far)
      ) :: any()
      when chunk: any
def foobar(enumerable, acc, chunk_fun, after_fun) do
  {_, {res, acc}} =
    case after_fun.(acc) do
      {:one, "one"} ->
        "one"

      {:two, "two"} ->
        "two"
    end
end
=-=-=


Name: String concatenation in call

=-=
IO.warn(
  "one" <>
    "two" <>
    "bar"
)

IO.warn(
  "foo" <>
    "bar"
)
=-=-=

Name: Incomplete map

=-=
map = {
:foo

=-=
map = {
  :foo

=-=-=

Name: Incomplete list

=-=
map = [
:foo

=-=
map = [
  :foo

=-=-=


Name: String concatenation

=-=
"one" <>
  "two" <>
  "three" <>
  "four"
=-=-=

