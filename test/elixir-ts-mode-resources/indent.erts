Code:
  (lambda ()
    (setq indent-tabs-mode nil)
    (elixir-ts-mode)
    (indent-region (point-min) (point-max)))

Point-Char: $

Name: Basic modules

=-=
defmodule Foobar do
def bar() do
"one"
      end
    end
=-=
defmodule Foobar do
  def bar() do
    "one"
  end
end
=-=-=


Name: Map

=-=
map = %{
  "a" => 1,
  "b" => 2
}
=-=-=

Name: Block assignments

=-=
foo =
  if true do
    "yes"
  else
    "no"
  end
=-=-=

Name: Function rescue

=-=
def foo do
  "bar"
rescue
  e ->
    "bar"
end
=-=-=


Name: Spec and method

=-=
@spec foobar(
        t,
        acc,
        (one, something -> :bar | far),
        (two -> :bar | far)
      ) :: any()
      when chunk: any
def foobar(enumerable, acc, chunk_fun, after_fun) do
  {_, {res, acc}} =
    case after_fun.(acc) do
      {:one, "one"} ->
        "one"

      {:two, "two"} ->
        "two"
    end
end
=-=-=

Name: With statement
=-=
with one <- one(),
     two <- two(),
     {:ok, value} <- get_value(one, two) do
  {:ok, value}
else
  {:error, {"Message" => message} ->
    {:error, message}
end
=-=-=

Name: Spec return type

=-=
@type result ::
        {:done, term}
        | {:two}
        | {:one}

@type result ::
        {
          :done,
          term
        }
        | {:two}
        | {:one}

@type boo_bar ::
        (foo :: pos_integer, bar :: pos_integer -> any())
=-=-=

Name: Spec return type comples

=-=
@spec foo_bar(
        t,
        (foo -> any),
        (() -> any) | (foo, foo -> boolean) | module()
      ) :: any
      when foo: any
def foo(one, fun, other)
=-=-=


Name: Pipe statements with fn

=-=
[1, 2]
|> Enum.map(fn num ->
  num + 1
end)
=-=-=

Name: Pipe statements with params

=-=
[1, 2]
|> Enum.map(
  one,
  two
)
=-=-=

Name: String concatenation

=-=
foo =
  "one" <>
    "two" <>
    "three"

"one" <>
  "two" <>
  "three" <>
  "four"
=-=-=


Name: String concatenation in call

=-=
IO.warn(
 "one " <>
   "two"
)
=-=-=
